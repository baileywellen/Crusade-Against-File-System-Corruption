/*      Bailey Wellen
        Computer Organization Spring 2019
        Project 6 - File Corruption */

        
#include <iostream>
#include <fstream>
#include <sys/mman.h>
#include <unistd.h>
#include <fcntl.h>
#include <vector>
//#include "my_stat.h"
#include "fs.h"
#include "types.h"
using namespace std;

struct myblock
{
    //marked_allocated - if the bitmap arary says that the data block is allocated, this will be true 
    bool marked_allocated;
    //dirent d;
    
};
struct myinode
{
    uint link_count;
    //bool marked_allocated - if it is 
    bool marked_allocated;
    //bool in-dir - if it is referenced in a directory, mark this as true 
    bool in_dir;
};

struct mydirectory
{
    
};

std::ifstream::pos_type filesize(const char* filename)
{
    std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);
    return in.tellg(); 
}
//pass inode_valid_size the array of inodes 
bool inode_valid_size(dinode* d[], uint size )
{   
    bool all_valid_sizes = true;
    //check if each one's -size is < (512 * MAXFILE)
    for (uint i = 0; i < size; i++)
    {
        if((d[i])->size > (512 * MAXFILE))
        {
            cout << "inode " << i << " has an invalid size " << endl;
            all_valid_sizes = false;
            break;
        }
    }
    return all_valid_sizes;
}
void check_types(dinode* d[], uint size)
{
    for (uint i = 0; i <size; i++)
    {
        cout << "type is " <<  d[i]->type << endl;
    }
}
bool valid_size(superblock* s, uint size)
{
    bool ret = true;
    //convert from bytes into blocks
    size = size / BSIZE;
    if (s->size != size)
    {
        cout << "invalid file size" << endl;
        ret = false;
    }
    return ret;
}
//fill all four vectors - one of your directories and one of files, and then special and unused 
void set_vectors(vector <dinode*> &directories, vector <dinode*> &files, vector <dinode*> &unused, vector <dinode*> &special, dinode * d[], uint size)
{
    cout << "SIZE: " << size << endl;
    for(uint i = 0; i < size; i++)
    {
        //Unused
        if (d[i]->type == 0)
        {
            unused.push_back(d[i]);
        }
        //Directory
        else if(d[i]->type == 1)
        {
            directories.push_back(d[i]);
        }
        //File
        else if(d[i]->type == 2)
        {
            files.push_back(d[i]);
        }
        //Directory
        else if(d[i]->type == 3)
        {
            special.push_back(d[i]);
        }
    }
}
//check if inode one is not a directory 
bool check_inode_1(dinode * d[])
{
    bool ret = true;
    if (d[1]->type != 1)
    {
        cout << "Inode 1 is not a directory " << endl;
         ret = false;
    }
    return ret;

}
//write a function that returns a bool - if the bit is 1, it returns true. if the bit is 0, it returns false 
//bmap is a pointer to the bitmap
//b is the 
//ninodes is the number of inodes 
struct find_bit
{
    uint block;
    uint byte;
    uint bit;
};
find_bit byte_offset(uint b, uint ninodes)
{
    find_bit this_bit;
    //which block in BM?
    this_bit.block  = BBLOCK(b, ninodes) * BSIZE;
    //which byte in that block? 
    this_bit.byte = b / 8;

    //which bit in that byte?
    //use num % 8 to compute which bit s
    this_bit.bit = b % 8;

    return this_bit;
}

bool bit_is_on(uchar* bitmap_ptr, uint b, uint ninodes )
{
    find_bit offset = byte_offset(b, ninodes);
    uchar* this_bit = bitmap_ptr + offset.block + offset.byte;
    //byte&(0x1 << bn)
    //return b & (0x1 << 1);
    //where bn is how many times you want to shift it over 
    bool bit_on = false;
    if (((*this_bit >> offset.bit)& 0x01))
    {
        bit_on = true;
    }

    return bit_on;
}
// bool check_directories(vector <dinode*> inode_directories)
// {
//     vector <dirent*> directories;
//     for(uint i = 0; i < inode_directories.size(); i++)
//     {
//         dirent* temp = inode_directories.at(i)->addrs;   
//     }
// }
bool check_names(vector <dirent*> dirent_vec)
{

}
int main(int argc, char* argv[])
{
	if (argc < 2)
	{
		cout << "not enough arguments entered" << endl;
		exit(1);
	}
    char* file = argv[1];
    int fd = open(file, O_RDONLY);
	if (fd == -1)
	{
		cout << "invalid file" << endl;
		exit(1);
	}

    void * file_copy = mmap(0, BSIZE * 1024, PROT_READ, MAP_SHARED, fd, 0);
    superblock * sb = (superblock*)(((char*)file_copy) + BSIZE);
    cout << "File System Project " << endl;
    cout << "Size of File System: " << sb->size << endl;
    cout << "Number of Inodes: " <<  sb->ninodes << endl;
    cout << "Number of Blocks: " << sb->nblocks << endl;
    cout << endl;

    //CHECK to make sure we have a valid sized file
     int size = filesize(argv[1]); 
    if (valid_size(sb, size) == false)
        exit(1);

    dinode * i_ptr = (dinode*)(((char*)file_copy) + (2 * BSIZE));
    dinode* dinode_array[sb->ninodes];
     for(uint i = 0; i < sb->ninodes - 1; i++)
     {
         dinode_array[i] = i_ptr;
        // cout << "inode " << i << " has link count "  << dinode_array[i]->nlink << " and size of " << dinode_array[i]->size << " and type " << dinode_array[i]->type << endl;
         i_ptr += 1;
     }
    
     cout << "CHECK TYPES : " << endl;
    //check_types(dinode_array, sb->ninodes - 1);

   
    //CHECK that all inode sizes are valid 
    if(inode_valid_size(dinode_array, sb->ninodes - 1) == false)
        exit(1);
    //CHECK to make sure that inode 1 is a directory 
    if(check_inode_1(dinode_array) == false )
        exit(1);
    
    //make an array of char* of size BSIZE  - each element is one byte - so 8 bits
    //(+ (2 * BSIZE )) gets us to the start of the inode array
    //(+ bs-> ninodes / IPB) gets us to the end of the inode array 
    uchar* bitmap_ptr = (uchar*) (((char*)file_copy) + (2 * BSIZE) + ((sb->ninodes / IPB) * BSIZE) + BSIZE);
    uchar* bitmap[BSIZE];

    //myinode bmap_inodes[BSIZE];


    for(uint i = 0; i < BSIZE; i++)
    {
        bitmap[i] = bitmap_ptr++;
       
       //make an array of blocks and whether or not they are marked as allocated
        // if(byte_is_on(bitmap, i, 7))
        // {
        //     bmap_inodes[i].marked_allocated = true;
        // }

        // //right shift logicals below 
        // cout << ((*bitmap[i]>>7)& 0x01);
        // cout << ((*bitmap[i]>>6)& 0x01);
        // cout << ((*bitmap[i]>>5)& 0x01);
        // cout << ((*bitmap[i]>>4)& 0x01);
        // cout << ((*bitmap[i]>>3)& 0x01);
        // cout << ((*bitmap[i]>>2)& 0x01);
        // cout << ((*bitmap[i]>>1)& 0x01);
        // cout << ((*bitmap[i]>>0)& 0x01);

        // cout << endl;

    }
    myblock inodes_referenced[sb->ninodes];
    for(uint i = 0; i < sb->ninodes; i++)
    {
        if(bit_is_on(bitmap_ptr, i, sb->ninodes) == true)
        {   
            inodes_referenced[i].marked_allocated = true;
        }
        else
        {
            inodes_referenced[i].marked_allocated = false;
        }
    }

    for(uint i = 0; i < sb->ninodes; i++)
    {
        cout << "on? " << inodes_referenced[i].marked_allocated << endl;
    }
    
  

   vector <dinode*> inode_files;
   vector <dinode*> inode_directories;
   vector <dinode*> inode_unused;
   vector <dinode*> inode_special;

   set_vectors(inode_directories, inode_files, inode_unused, inode_special, dinode_array, sb->ninodes - 1);
   cout << "directories: " <<  inode_directories.size() << endl;
   cout << "files: " <<  inode_files.size() << endl;

   //LOAD DIRECTORIES

   vector <dirent*> dirent_vec;

    //loop through the inodes that are directories 
   for (uint i = 0; i < inode_directories.size(); i++)
   {
       //Every directory size has to be a multiple of 512 - check that here 
       for(uint k = 0; k < 11; k++)
       {
            dirent* data_section = (dirent*) (((uchar*) file_copy) + inode_directories[i]->addrs[k] * BSIZE);
            //the data_end pointer points to the end of that block 
            for(dirent* ptr = data_section; ptr != data_section + (BSIZE / sizeof(dirent)); ptr++)
            {
                //as long as it is not used, we should push each directory into the vector 
                if(ptr->inum != 0)
                {
                    dirent_vec.push_back(ptr);
                    cout << "the Inum is " << ptr->inum << " the name is " << (string)ptr->name << endl;
                }        
            }
       }
   }



    close(fd);
    munmap(file_copy, BSIZE * 1024);
	return 0;
}
